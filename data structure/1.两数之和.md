### 题目：1.两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_  的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

**示例 1：**
```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```
**示例 2：**
```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```
**示例 3：**
```
输入：nums = [3,3], target = 6
输出：[0,1]
```

**提示：**

- 2 <= nums.length <= 104
- -109 <= nums[i] <= 109
- -109 <= target <= 109
- **只会存在一个有效答案**

**进阶：**
你可以想出一个时间复杂度小于 `O(N2)` 的算法吗？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/two-sum

### 解题过程
#### 提交1
```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> result;
        vector<int> origin(nums.begin(), nums.end());
        int ladd = -1;
        int radd = -1;
        sort(nums.begin(), nums.end());
        for (size_t idx = 0; idx < nums.size() && nums[idx] <= target; ++idx) {
            int addnum = target - nums[idx];
            size_t low = idx + 1, high = nums.size() - 1;
            while (low <= high) {
                size_t mid = (low + high) / 2;
                if (nums[mid] == addnum) {
                    ladd = nums[idx];
                    radd = addnum;
                    break;
                }
                else if (nums[mid] > target) {
                    high = mid - 1;
                }
                else {
                    low = mid + 1;
                }
            }
        }
        auto liter = find(origin.begin(), origin.end(), ladd);
        *liter += 1;
        int lindex = distance(origin.begin(), liter);
        auto riter = find(origin.begin(), origin.end(), radd);
        int rindex = distance(origin.begin(), riter);
        result.push_back(lindex);
        result.push_back(rindex);
        return result;
    }
};
```
**结果：** 解答错误

**分析：**
测试用例
```[-1,-2,-3,-4,-5]
    -8
```
不能通过，输出错误结果`[0, 5]`。原因在于
```C++
else if (nums[mid] > target) {
    high = mid - 1;
}
```
中，应该和另一个加数`addnum`进行比较，却错误写成了和`target`比较。

#### 提交2
```C++
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        vector<int> dic;
        for (auto elem : nums){
            auto it = find(dic.begin(), dic.end(), elem);
            if (it != dic.end())
                return true;
            else {
                dic.push_back(elem);
            }
        }
        return false;
    }
};
```
**结果：** 执行用时: 1772 ms       内存消耗: 46.2 MB

**分析：**
想使用空间换时间，第一次出现的数都放在一个辅助数组中，每次遇到当前处理元素，先查辅助数组是否有，若有则重复，没有则插入辅助数组。
结果执行用时还是太长，原因在于辅助数组采用vector, `find()`的时间复杂度为`O(N)`, 因此总体时间复杂度仍为`O(N*N)`。
与“提交1”相比，快在内层循环找到即停止，而不需要总是遍历完再得到总计数。
因此虽然通过，但执行用时太长。
