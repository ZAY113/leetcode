### 题目：1.两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_  的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

**示例 1：**
```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```
**示例 2：**
```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```
**示例 3：**
```
输入：nums = [3,3], target = 6
输出：[0,1]
```

**提示：**

- 2 <= nums.length <= 104
- -109 <= nums[i] <= 109
- -109 <= target <= 109
- **只会存在一个有效答案**

**进阶：**
你可以想出一个时间复杂度小于 `O(N2)` 的算法吗？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/two-sum

### 解题过程
#### 提交1
```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> result;
        vector<int> origin(nums.begin(), nums.end());
        int ladd = -1;
        int radd = -1;
        sort(nums.begin(), nums.end());
        for (size_t idx = 0; idx < nums.size() && nums[idx] <= target; ++idx) {
            int addnum = target - nums[idx];
            size_t low = idx + 1, high = nums.size() - 1;
            while (low <= high) {
                size_t mid = (low + high) / 2;
                if (nums[mid] == addnum) {
                    ladd = nums[idx];
                    radd = addnum;
                    break;
                }
                else if (nums[mid] > target) {
                    high = mid - 1;
                }
                else {
                    low = mid + 1;
                }
            }
        }
        auto liter = find(origin.begin(), origin.end(), ladd);
        *liter += 1;
        int lindex = distance(origin.begin(), liter);
        auto riter = find(origin.begin(), origin.end(), radd);
        int rindex = distance(origin.begin(), riter);
        result.push_back(lindex);
        result.push_back(rindex);
        return result;
    }
};
```
**结果：** 解答错误

**分析：**
测试用例
```
[-1,-2,-3,-4,-5]
-8
```
不能通过，输出错误结果`[0, 5]`。原因在于
1. 
```C++
else if (nums[mid] > target) {
    high = mid - 1;
}
```
中，应该和另一个加数`addnum`进行比较，却错误写成了和`target`比较。
2. ![image](https://user-images.githubusercontent.com/41363767/155663891-bd039d75-33fe-477f-b12e-d74970183ae3.png)
上述代码中，在内层循环找到另一个加数时，任务已经完成，
此时不仅要退出内层while循环，外层for循环也应该退出，

#### 提交2
```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> result;
        vector<int> origin(nums.begin(), nums.end());
        int ladd = -1;
        int radd = -1;
        sort(nums.begin(), nums.end());
        bool flag = true;
        for (size_t idx = 0; idx < nums.size() && flag; ++idx) {
            int addnum = target - nums[idx];
            size_t low = idx + 1, high = nums.size() - 1;
            while (low <= high) {
                size_t mid = (low + high) / 2;
                if (nums[mid] == addnum) {
                    ladd = nums[idx];
                    radd = addnum;
                    flag = false;
                    break;
                }
                else if (nums[mid] > target) {
                    high = mid - 1;
                }
                else {
                    low = mid + 1;
                }
            }
        }
        auto liter = find(origin.begin(), origin.end(), ladd);
        *liter += 1;
        int lindex = distance(origin.begin(), liter);
        auto riter = find(origin.begin(), origin.end(), radd);
        int rindex = distance(origin.begin(), riter);
        result.push_back(lindex);
        result.push_back(rindex);
        sort(result.begin(), result.end());
        return result;
    }
};
```
**结果：** 解答错误

**分析：**
采用设置布尔变量`flag`来在找到两个加数的值之后在`break`退出内层while循环基础上，接着退出外层for循环。
测试用例
```
[1, 2, 3, ..., 9998, 9999, 10000]
19999
```
不能通过，输出错误结果`[9998, 9998]`。原因在于
对类如`[3, 3], 6`的用例求解时，采取了![image](https://user-images.githubusercontent.com/41363767/155664845-54a32cf1-1527-4999-9645-484221e94532.png)的操作来修改第一个加数，从而防止两次`find()`为同一索引，返回`[0, 0]`（正确结果应为`[0,1]`）。
但当面对上述未能通过的用例，搜索到元素9999时，此时下标索引为9998，`find()`到第一个加数，并将其加1修改为`10000`，第二次`find()`寻找另一个加数时，刚好等于修改后的第一个加数所在位置，因而返回了`[9998, 9998]`。
事实上，`find()`返回第一个加数后，若不更改数据，直接第二次`find()`，则会面临当两个加数相同时，返回的索引都是第一个加数的下标；

而若对一个加数修改，无论是加一还是减一抑或其他，只要在可能出现的取值范围之内，当另一个加数恰好等于修改后的数据时，总是会出现错误；

并且设置为范围之外的数`1e5=9+1`则会超出`int`类型的存储范围。

因此只能将第二次`find()`操作切分为两次查找，设第一个加数索引为x, 先查找[0, x)，再查找[x+1, end)，即越过对第一个加数的查找，即可解决问题。
