### 题目：剑指offer 10-I.斐波那契数列
写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

**示例 1：**
```
输入：n = 2
输出：1
```
**示例 2：**
```
输入：n = 5
输出：5
```

**提示：**
- 0 <= n <= 100

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof

### 解题过程
#### 提交1 - 递归
```C++
class Solution {
public:
    int fib(int n) {
        if (n == 0)
            return 0;
        if (n == 1)
            return 1;
        const int M = 1e9 + 7;
        return (fib(n - 1) + fib(n - 2)) % M;
    }
};
```
**结果：** 超出时间限制

**分析：**

从斐波那契数列定义就可以看出是递归定义的，最直接的写法就是递归写法。但是n最大为100，递归深度达到100是不可接受的，试着提交果然超出时间限制。

最后执行输入为43，已经超时，远远不能满足要求。 

这是因为递归是从n开始回退到0，将求解看作一棵树，自顶向下的计算会导致出现大量重复计算，比如对F(2)的重复计算就会非常多。

优化思路是避免重复计算，自然的想法就是自底向上，或者说从0开始逐渐向n推算。


#### 提交2 - 动态规划
```C++
class Solution {
public:
    int fib(int n) {
        if (n == 0)
            return 0;
        if (n == 1)
            return 1;
        int last1 = 1;
        int last2 = 0;
        int result;
        const int M = 1e9 + 7;
        for (int i = 2; i <= n; ++i) {
            result = (last1 + last2) % M;
            last2 = last1;
            last1 = result;
        }
        return result;
    }
};
```
**结果：** 执行用时: 0 ms        内存消耗: 5.8 MB

**分析：**

要从0向n进行推算，每次计算f(n)，都需要保存前面两个值：f(n-1)和f(n-2)，且只需要这两个值就可以推算出下一个值。

于是定义两个变量来记忆每次计算目标的前两个函数值，当推算出本次目标后，更新这两个变量，向前推进。

即动态规划的思想。

- 时间复杂度：`O(n)`
- 空间复杂度：`O(1)`

