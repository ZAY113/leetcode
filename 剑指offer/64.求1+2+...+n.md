### 题目：剑指offer 64.求1+2+...+n.md
求 `1+2+...+n` ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

**示例 1：**
```
输入: n = 3
输出: 6
```
**示例 2：**
```
输入: n = 9
输出: 45
```

**限制：**
- `1 <= n <= 10000`

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/qiu-12n-lcof

### 解题过程

没看清题，以为只是不能使用乘除法，然后觉得for循环累加复杂度为`O(n)`，不会这么简单，肯定是复杂度要降到`O(logn)`。

看到“位运算”的tag，一直思考如何直接用位运算完成从1加到n，将1到n全部展开二进制，结果想不出来。

### 题解
#### 方法一： 递归替代循环，&&和||的短路运算替代if-else语句
```C++
====================================
class Solution {
public:
    int sumNums(int n) {
        n && (n += sumNums(n - 1));
        return n;
    }
};
====================================
class Solution {
public:
    int sumNums(int n) {
        n == 0 || (n = n + sumNums(n - 1));
        return n;
    }
};
====================================
```
**结果：** 执行用时: 0 ms            内存消耗: 6.1 MB

**分析：**

仔细体会递归如何替代循环，短路运算如何替代if-else语句

**复杂度分析：**
- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`


#### 方法二： 快速乘
```C++
class Solution {
public:
    int sumNums(int n) {
        int a = n, b = n + 1;
        int ans = 0;
        // n最大为10000, 2^13 = 8192, 2^14 = 16384
        // 1
        (b & 1) && (ans += a);
        a <<= 1;
        b >>= 1;
        // 2
        (b & 1) && (ans += a);
        a <<= 1;
        b >>= 1;
        // 3
        (b & 1) && (ans += a);
        a <<= 1;
        b >>= 1;
        // 4
        (b & 1) && (ans += a);
        a <<= 1;
        b >>= 1;
        // 5
        (b & 1) && (ans += a);
        a <<= 1;
        b >>= 1;
        // 6
        (b & 1) && (ans += a);
        a <<= 1;
        b >>= 1;
        // 7
        (b & 1) && (ans += a);
        a <<= 1;
        b >>= 1;
        // 8
        (b & 1) && (ans += a);
        a <<= 1;
        b >>= 1;
        // 9
        (b & 1) && (ans += a);
        a <<= 1;
        b >>= 1;
        // 10
        (b & 1) && (ans += a);
        a <<= 1;
        b >>= 1;
        // 11
        (b & 1) && (ans += a);
        a <<= 1;
        b >>= 1;
        // 12
        (b & 1) && (ans += a);
        a <<= 1;
        b >>= 1;
        // 13
        (b & 1) && (ans += a);
        a <<= 1;
        b >>= 1;
        // 14
        (b & 1) && (ans += a);
        a <<= 1;
        b >>= 1;
        return ans >> 1;
    }
};
```
**结果：** 执行用时: 0 ms            内存消耗: 5.8 MB

**分析：**

求`1+2+...+n`，只需计算`n(n+1)/2`，其中除以2可以用右移一位来替代，
则只需计算`n(n+1) >> 1`。

如何使用`O(logn)`的时间复杂度实现乘法运算（快速乘）
```
int quickMulti(int A, int B) {
    int ans = 0;
    for ( ; B; B >>= 1) {
        if (B & 1) {
            ans += A;
        }
        A <<= 1;
    }
    return ans;
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/qiu-12n-lcof/solution/qiu-12n-by-leetcode-solution/
来源：力扣（LeetCode）
```
需要仔细理解上述快速乘算法。

接下来只需要替换其中for循环和if语句即可：
- 对for循环，因为n的最大可能值为10000，所以其二进制展开最多不会超过14位，只需手动展开循环14次；
- 对if语句，依然是使用&&的短路操作。


**复杂度分析：**
- 时间复杂度：`O(logn)`
- 空间复杂度：`O(1)`
