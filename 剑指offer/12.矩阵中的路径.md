### 题目：剑指offer 12.矩阵中的路径
给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。


例如，在下面的 3×4 的矩阵中包含单词 "ABCCED"（单词中的字母已标出）。

![image](https://user-images.githubusercontent.com/41363767/161917700-b0224d73-cd85-4666-bb87-6d0c81d45040.png)

**示例 1：**
```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```
**示例 2：**
```
输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```
 
**提示：**
- 1 <= board.length <= 200
- 1 <= board[i].length <= 200
- `board` 和 `word` 仅由大小写英文字母组成
 
**注意：** 本题与主站 79 题相同：https://leetcode-cn.com/problems/word-search/

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof


### 解题过程
#### 提交1
```C++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        if (board.size() == 0 || board[0].size() == 0 || word.empty())
            return false;
        int idx = 0;
        return search(board, 0, 0, word, idx);
    }

    bool search(vector<vector<char>>& board, int i, int j, string& word, int& idx) {
        bool result = false;
        if (i >= 0 && i < board.size() && j >= 0 && j < board.size() && board[i][j] == word[idx]) {
            if (idx == word.size() - 1)
                return true;
            board[i][j] = NULL;
            if (j < board[0].size()-1 && board[i][j + 1] != NULL)
                result = search(board, i, j + 1, word, ++idx);
            if (!result && i < board.size()-1 && board[i + 1][j] != NULL)
                result = search(board, i + 1, j, word, ++idx);
            if (!result && j > 0 && board[i][j - 1] != NULL)
                result = search(board, i, j - 1, word, ++idx);
            if (!result && i > 0 && board[i - 1][j] != NULL)
                result = search(board, i - 1, j, word, ++idx);
        }
        if (result)
            return true;
        else {
            --idx;
            return false;
        }
    }
};
```
**结果：** 解答错误

**分析：**

对测试用例
```
[["a","a"]]
"aa"
```
错误输出了false。原因在于search函数中第一条if语句对j的范围判断`j < board.size()`应该为`j < board[0].size()`，因为递归在第二个`a`虽然`board[i][j] == word[idx]`应该为true，
但是此时`j=1`，而`board.size()`代表行的维度，也是1，造成条件判断为false，从而输出false。

建议提前写
```
int row = board.size();
int column = borad[0].size();
```
避免出现漏掉维度的错误。不要每次都在条件判断中写。


#### 提交2
```C++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        if (board.size() == 0 || board[0].size() == 0 || word.empty())
            return false;
        int idx = 0;
        return search(board, 0, 0, word, idx);
    }

    bool search(vector<vector<char>>& board, int i, int j, string& word, int& idx) {
        bool result = false;
        if (i >= 0 && i < board.size() && j >= 0 && j < board[0].size() && board[i][j] == word[idx]) {
            if (idx == word.size() - 1)
                return true;
            board[i][j] = NULL;
            if (j < board[0].size()-1 && board[i][j + 1] != NULL)
                result = search(board, i, j + 1, word, ++idx);
            if (!result && i < board.size()-1 && board[i + 1][j] != NULL)
                result = search(board, i + 1, j, word, ++idx);
            if (!result && j > 0 && board[i][j - 1] != NULL)
                result = search(board, i, j - 1, word, ++idx);
            if (!result && i > 0 && board[i - 1][j] != NULL)
                result = search(board, i - 1, j, word, ++idx);
        }
        if (result)
            return true;
        else {
            --idx;
            return false;
        }
    }
};
```
**结果：** 解答错误

**分析：**

对测试用例
```
[["a","b"]]
"ba"
```
忽视了矩阵中任意一个点都可以作为匹配的起始点，代码默认都是从矩阵左上角开始进行字符串匹配，这是不全面的。


#### 提交3
```C++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        if (board.size() == 0 || board[0].size() == 0 || word.empty())
            return false;
        bool result = false;
        for (int i = 0; i < board.size(); ++i){
            for (int j = 0; j < board[0].size(); ++j) {
                int idx = 0;
                //vector<vector<char>> b;
                result = search(board, i, j, word, idx);
                if (result)
                    return result;
            }
        }
        return false;
    }

    bool search(vector<vector<char>>& board, int i, int j, string& word, int& idx) {
        bool result = false;
        if (i >= 0 && i < board.size() && j >= 0 && j < board[0].size() && board[i][j] == word[idx]) {
            if (idx == word.size() - 1)
                return true;
            //board[i][j] = NULL;
            if (j < board[0].size()-1 && board[i][j + 1] != NULL)
                result = search(board, i, j + 1, word, ++idx);
            if (!result && i < board.size()-1 && board[i + 1][j] != NULL)
                result = search(board, i + 1, j, word, ++idx);
            if (!result && j > 0 && board[i][j - 1] != NULL)
                result = search(board, i, j - 1, word, ++idx);
            if (!result && i > 0 && board[i - 1][j] != NULL)
                result = search(board, i - 1, j, word, ++idx);
        }
        if (result)
            return true;
        else {
            --idx;
            return false;
        }
    }
};
```
**结果：** 解答错误

**分析：**

这里的困扰点在于：因为矩阵中每个位置都要做一次匹配的起始位置，而每确定一次起始位置并开始匹配过程时，途中总是不停的将已走过的位置设为无效值，以避免重复走回头路。
但一个起始位置匹配结束后，矩阵中大量元素被设置为无效值，为了能让下一个起始位置的匹配流程顺利进行，必须想办法保留或恢复原有矩阵。

这里先尝试注释掉修改元素为无效值的语句进行测试。

果然对测试用例
```
[["a","a"]]
"aaa"
```
在从[0][0]开始匹配，匹配到[0][1]时矩阵元素已经用完，而字符串下一个字符仍为`a`，由于代码中走过的元素没有被设置为NULL，因此又回头返回 [0][0]匹配，并且错误输出了true。

需要思考如何在设置为NULL之后恢复原矩阵内容。


#### 提交4
```C++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        if (board.size() == 0 || board[0].size() == 0 || word.empty())
            return false;
        bool result = false;
        for (int i = 0; i < board.size(); ++i){
            for (int j = 0; j < board[0].size(); ++j) {
                int idx = 0;
                vector<vector<char>> b(board);
                result = search(b, i, j, word, idx);
                if (result)
                    return result;
            }
        }
        return false;
    }

    bool search(vector<vector<char>>& board, int i, int j, string& word, int& idx) {
        bool result = false;
        if (i >= 0 && i < board.size() && j >= 0 && j < board[0].size() && board[i][j] == word[idx]) {
            if (idx == word.size() - 1)
                return true;
            board[i][j] = NULL;
            if (j < board[0].size()-1 && board[i][j + 1] != NULL)
                result = search(board, i, j + 1, word, ++idx);
            if (!result && i < board.size()-1 && board[i + 1][j] != NULL)
                result = search(board, i + 1, j, word, ++idx);
            if (!result && j > 0 && board[i][j - 1] != NULL)
                result = search(board, i, j - 1, word, ++idx);
            if (!result && i > 0 && board[i - 1][j] != NULL)
                result = search(board, i - 1, j, word, ++idx);
        }
        if (result)
            return true;
        else {
            --idx;
            return false;
        }
    }
};
```
**结果：** 解答错误

**分析：**

采用了每次更换匹配起始点之前拷贝一份原始矩阵的方式来克服上述问题。

但对测试用例
```
[["A","B","C","E"],["S","F","E","S"],["A","D","E","E"]]
"ABCEFSADEESE"
```
错误输出为false，应该为true。经过调试发现，在第一次走过[0][3]的`E`时，与字符串的`word[3]`成功匹配，而在搜索[1][1]的`F`时会途径[1][2]的`E`，
此时由于递归出栈的原因，`word`的下标已经回退，因此重复判断了[1][2]的`E`与`word[3]`的`E`，在判断完之后将[1][2]置为`NULL`，
导致后面在判断`word[11]`的最后一个`E`时，应该恰好和[1][2]的`E`匹配成功，并返回true，但此时已经
